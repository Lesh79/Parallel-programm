## Исходный проект

Проанализирован проект на `C`, демонстрирующий решение задачи
об [обедающих философах](https://github.com/dpetrosy/42-Philosophers) без использования `OpenMP`:
репозиторий. В проекте реализована многопоточная система с использованием мьютексов для синхронизации потоков философов,
а также потока наблюдателя, который следит за завершением трапезы.

## Анализ работы программы

Приложение инициализирует мьютексы и запускает потоки философов, которые выполняют бесконечные циклы. Поток наблюдателя
следит за состоянием философов и завершает программу после окончания их трапезы. Завершение программы сопровождается
уничтожением мьютексов.

## Использование ThreadSanitizer и Helgrind

Для анализа программы были добавлены флаги `-fsanitize=thread -g` в Makefile. При запуске `./philo 5 800 200 200 7` были
выявлены следующие ошибки:

- ThreadSanitizer:
    - Уничтожение заблокированного мьютекса: `destroy of a locked mutex`
    - Попытка разблокировки разрушенного мьютекса: `unlock of an unlocked mutex`
    - Гонка данных: `data race`

**Helgrind** также подтвердил наличие гонок данных и зафиксировал несколько ошибок, связанных с уничтожением
заблокированных мьютексов.

### Причина ошибок

Гонки данных возникают из-за того, что поток наблюдателя вызывает функцию уничтожения мьютексов до того, как философы
успевают их освободить. Это приводит к некорректному поведению программы, так как попытка уничтожить заблокированный
мьютекс или освободить разрушенный мьютекс вызывает непредсказуемые результаты.

### Решение проблемы

Для устранения ошибок была внесена правка: логика завершения трапезы теперь выполняется внутри потоков философов, что
гарантирует освобождение мьютексов до их уничтожения. После внесения изменений все ошибки, выявленные ThreadSanitizer,
исчезли. Helgrind больше не фиксирует гонки данных, но продолжает выдавать предупреждения о блокировке мьютексов вилок
разными философами, что является частью корректной логики программы.